# -*- coding: utf-8 -*-
"""Rewiring_Food Web.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GGYqX4k95cc-L6SmFT62cUhb9wUHVc0j
"""

from collections import defaultdict
import csv
from random import shuffle
import random
import networkx as nx
import matplotlib.pyplot as plt
from matplotlib import patches
import numpy as np


def data_collection_csv(csv_data):
    graph=defaultdict(list)
    with open(csv_data) as infile:
        reader=csv.reader(infile)
        for row in reader:
            try:
                graph[row[0]].append(row[1])
            except IndexError:
                pass
    return graph

def collection_nodes(data):
    nodes=[]
    # for each node in graph
    for node in data:
        for consumer in data[node]:
            # if edge exists then append
            if node != consumer:
                nodes.append(node)
                nodes.append(consumer)
    nodes= list(set(nodes))
    return nodes

def get_edges(data):
    edges = []
    # for each node in graph
    for node in data:

        # for each neighbour node of a single node
        for consumer in data[node]:
            # if edge exists then append
            if node != consumer:
                edges.append((node, consumer))

    return edges

def generate_rewire_edges(data):
    links = data
    # print(links)
    prey_list = set([lis[0] for lis in links])
    pred_list = set([lis[1] for lis in links])
    # print(pred_list)
    rewire_list = []
    for li in pred_list:
        for position in links:
            for check in links:
                if (position[0] == li and position[1] == check[1]):
                    rewire_list.append((li, check[0]))

    list = [(a, b) for a, b in rewire_list if a != b]
    rewire = {tuple(item) for item in map(sorted, list)}

    return rewire

def node_removal(data, node_remove):
    simulated_edges=[]
    shuffle(node_remove)

    length=len(node_remove)
    # print(length)

    k=1
    for x in node_remove:
        # print(x)
        wire = generate_rewire_edges(data)
        wire = [i for i in wire if i[0] != x and i[1] != x]
        # print(wire)
        new_edges = [i for i in data if i[0] != x and i[1] != x]
        # print(new_edges)
        latest_full=new_edges + list(wire)
        # print(latest_full)

        wire1=generate_rewire_edges(new_edges)
        # print(len(wire1))

        if k == length:
            simulated_edges.append(latest_full)

        data = new_edges
        wire=wire1
        k+=1

    return simulated_edges

def draw_adjacency_matrix(G, node_order=None, partitions=[], colors=[]):
    """
    - G is a netorkx graph
    - node_order (optional) is a list of nodes, where each node in G
          appears exactly once
    - partitions is a list of node lists, where each node in G appears
          in exactly one node list
    - colors is a list of strings indicating what color each
          partition should be
    If partitions is specified, the same number of colors needs to be
    specified.
    """
    adjacency_matrix = nx.to_numpy_matrix(G, dtype=np.bool, nodelist=node_order)

    # Plot adjacency matrix in toned-down black and white
    fig = plt.figure(figsize=(3, 3))  # in inches
    plt.imshow(adjacency_matrix,
                  cmap="Greys",
                  interpolation="none", extent=[0, 1, 0, 1])

    # The rest is just if you have sorted nodes by a partition and want to
    # highlight the module boundaries
    # assert len(partitions) == len(colors)
    # ax = plt.gca()
    # for partition, color in zip(partitions, colors):
    #     current_idx = 0
    #     for module in partition:
    #         ax.add_patch(patches.Rectangle((current_idx, current_idx),
    #                                        len(module),  # Width
    #                                        len(module),  # Height
    #                                        facecolor="none",
    #                                        edgecolor=color,
    #                                        linewidth="1"))
    #         current_idx += len(module)

if __name__ == "__main__":

    #Collecting data from control web and Drough web csvs
    control_1=data_collection_csv('trophic.linksc4.csv')
    drought_1=data_collection_csv('trophic.linksd4.csv')

    # print(control_1)
    # collection of nodes present in the csv files
    nodes_1=collection_nodes(control_1)
    nodes_2=collection_nodes(drought_1)
    # print(nodes_1)

    #Nodes are not present in the Drought data
    diff_list=list(set(nodes_1) - set(nodes_2))
    # print(diff_list)

    #Get all edges from data
    control_edges=get_edges(control_1)
    # drought_edges = get_edges(drought_1)

    collect_simulated=[]
    z = 1
    while z <= 100:
        # Random removal of the nodes
        simulated_edges = node_removal(control_edges, diff_list)
        collect_simulated.append(simulated_edges)
        z += 1
    # print(collect_simulated)

    #Average calculation of all edges
    newlist = [item for items in collect_simulated for item in items]
    #print(newlist)
    newlist1 = [item for items in newlist for item in items]
    list_set = set(newlist1)

    # average = [ele for ele in average_simulated_edges if ele in nodes_2]
    # Graph adjacency graph for control
    G = nx.DiGraph()
    G.add_edges_from(newlist1)
    draw_adjacency_matrix(G)
    plt.savefig("simulated.png")

    # Drought network Analaysis
    node_control = nodes_2
    # print(node_control)
    edges2 = get_edges(drought_1)
    # print(edges2)

    # edges2 = [ele for ele in average_simulated_edges if ele in edges2]
    # Graph adjacency graph for control
    H = nx.DiGraph()
    H.add_edges_from(edges2)
    r = list(set(set(H.nodes)) - set(G.nodes()))
    # print(r)
    RandomSample = random.sample(r, 2)
    r.remove(RandomSample[0])
    H.remove_nodes_from(RandomSample)

    draw_adjacency_matrix(H)
    plt.savefig("Drought.png")

    print("Simualated Graph Analysis")
    print("Total number of nodes: ", int(G.number_of_nodes()))
    print("Total number of edges: ", int(G.number_of_edges()))
    # print("List of all nodes: ", list(G.nodes()))
    # print("List of all edges: ", list(G.edges(data=True)))
    # print("Degree for all nodes: ", dict(G.degree()))
    

    print("Drought Graph Analysis")
    print("Total number of nodes: ", int(H.number_of_nodes()))
    print("Total number of edges: ", int(H.number_of_edges()))
    # print("List of all nodes: ", list(H.nodes()))
    # print("List of all edges: ", list(H.edges(data=True)))
    # print("Degree for all nodes: ", dict(H.degree()))

    
    difference_graph_edges = [i for i in list(G.edges()) if i not in list(H.edges())]
    # difference_graph_edges =set(simulated_edges) - set(edges2)
    length = len(difference_graph_edges)
    print("Diffriences in graph edges")
    print("Total number of Edge difference: ", length)
    print(difference_graph_edges)

    print("Common in graph edges")
    common_graph_edges = [i for i in list(G.edges()) if i in list(H.edges())]
    length = len(common_graph_edges)
    print("Total number of Common edges: ", length)
    print(common_graph_edges)

    # K = nx.DiGraph()
    # K.add_edges_from(common_graph_edges)
    # draw_adjacency_matrix(K)
    # plt.savefig("Common_graph.png")